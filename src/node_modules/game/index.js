import 'game/style.css'; // webpack magic
import {Container, Graphics, Point, Rectangle, SCALE_MODES, settings, Sprite} from 'pixi.js';
settings.SCALE_MODE = SCALE_MODES.NEAREST;

import * as engine from 'engine';
import * as display from 'engine/display';
import * as input from 'engine/input';
import * as resources from 'engine/resources';
import Scene from 'engine/Scene';
import TileGrid from './TileGrid';

const GRAVITY = 800;
const RAVE_INTERVAL_MS = 1000 * 1;

const LEVEL = [
  '##################################',
  '#*                               #',
  '#                                #',
  '#                                #',
  '#                                #',
  '#                                #',
  '##################################',
];

const TILE_SIZE = 64;

class TestScene extends Scene {
  init() {
    this.raveHandle = window.setInterval(() => {
      // this.randomizeBackgroundColor();
    }, RAVE_INTERVAL_MS);
    const sprite = this.sprite = Sprite.fromFrame('bunny');
    sprite.tint = 0x00FFFF;
    sprite.anchor.set(0.5, 0.5);
    sprite.position.set(300, 100);
    sprite.velocity = new Point();
    sprite.grounded = false;
    this.stage.addChild(sprite);
    const tiles = this.tiles = new Container();
    this.stage.addChild(tiles);
    const grid = this.grid = new TileGrid(LEVEL);
    grid.forEach((tile, x, y) => {
      if (tile == '#') {
        const ts = Sprite.fromFrame('happy');
        ts.tx = x;
        ts.ty = y;
        ts.position.set(x * TILE_SIZE, y * TILE_SIZE);
        ts.width = TILE_SIZE;
        ts.height = TILE_SIZE;
        tiles.addChild(ts);
      } else if (tile == '*') {
        sprite.center = new Point(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
      }
    });
    tiles.children.forEach((ts) => {
      const tx = ts.tx;
      const ty = ts.ty;
      ts.collision = {
        up: !grid.has(tx, ty - 1),
        down: !grid.has(tx, ty + 1),
        left: !grid.has(tx - 1, ty),
        right: !grid.has(tx + 1, ty),
      };
      if (!tx && !ty) {
        window.scene = this;
      }
    });
    this.graphics = new Graphics();
    this.ui.addChild(this.graphics);
  }
  dispose() {
    window.clearInterval(this.raveHandle);
  }
  update(delta) {
    if (input.keyPressed('Space')) {
      this.randomizeBackgroundColor();
    }
    const goLeft = input.keyDown('KeyA');
    const goRight = input.keyDown('KeyD');
    const jump = input.keyPressed('KeyW');
    if (goLeft && !goRight) {
      this.sprite.velocity.x = -300;
    } else if (goRight && !goLeft) {
      this.sprite.velocity.x = 300;
    } else {
      this.sprite.velocity.x = 0;
    }
    if (jump && this.sprite.grounded) {
      this.sprite.velocity.y = -500;
    }
    this.sprite.grounded = false;
    this.sprite.velocity.y += GRAVITY * delta / 2;
    this.sprite.position.add(this.sprite.velocity, delta);
    this.sprite.velocity.y += GRAVITY * delta / 2;
    let sb = this.sprite.getBounds();
    this.tiles.children.forEach((tile) => {
      const tileBounds = tile.getBounds();
      const collision = Rectangle.getTileCollision(sb, tileBounds, tile.collision);
      if (!collision) {
        return;
      }
      const oldY = this.sprite.position.y;
      this.sprite.position.add(collision);
      const newY = this.sprite.position.y;
      if (newY <= oldY) {
        this.sprite.grounded = true;
      }
      if (collision.x) {
        this.sprite.velocity.x = 0;
      }
      if (collision.y) {
        this.sprite.velocity.y = 0;
      }
      sb = this.sprite.getBounds();
    });
    this.graphics.clear();
    this.graphics.beginFill(0xFF00FF, 1.0);
    const r = this.sprite.getBounds();
    this.graphics.drawRect(r.x, r.y, r.width, r.height);
    this.graphics.endFill();
    this.tiles.children.forEach((tile) => {
      this.graphics.beginFill(0xFFFF00, 1.0);
      const r = tile.getBounds();
      this.graphics.drawRect(r.x, r.y, r.width, r.height);
      this.graphics.endFill();
    });
    this.stage.position.set(
      display.width / 2 - this.sprite.position.x,
      display.height / 2 - this.sprite.position.y);
  }
  randomizeBackgroundColor() {
    this.backgroundColor = Math.floor(Math.random() * 0xFFFFFF);
  }
}

engine.launch(new TestScene());

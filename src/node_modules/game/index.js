import 'game/style.css'; // webpack magic
import {Container, Graphics, Point, Rectangle, SCALE_MODES, settings, Sprite} from 'pixi.js';
settings.SCALE_MODE = SCALE_MODES.NEAREST;

import * as engine from 'engine';
import * as display from 'engine/display';
import * as input from 'engine/input';
import Scene from 'engine/Scene';
import TileGrid from './TileGrid';

import * as resources from 'engine/resources';

const GRAVITY = 1000;

const LEVEL = [
  '##################################',
  '#*                               #',
  '#                                #',
  '#                                #',
  '#                                #',
  '#                                #',
  '##################################',
];

const TILE_SIZE = 32;
const JUMP_HEIGHT = TILE_SIZE * 2.5;
const JUMP_SPEED = Math.sqrt(2 * GRAVITY * JUMP_HEIGHT);

class TestScene extends Scene {
  init(debug = false) {
    this.backgroundColor = 0x335599;
    this.player = {
      bounds: new Rectangle(0, 0, TILE_SIZE * 0.9, TILE_SIZE * 0.75),
      velocity: new Point(),
    };
    const sprite = this.sprite = resources.loadAnimation('dog/walk', 8);
    sprite.anchor.set(0.5, 1.0);
    this.stage.addChild(sprite);
    const tiles = this.tiles = new Container();
    this.stage.addChild(tiles);
    const grid = this.grid = new TileGrid(LEVEL);
    grid.forEach((tile, x, y) => {
      if (tile == '#') {
        const ts = Sprite.fromFrame('happy');
        ts.tx = x;
        ts.ty = y;
        ts.position.set(x * TILE_SIZE, y * TILE_SIZE);
        ts.width = TILE_SIZE;
        ts.height = TILE_SIZE;
        ts.physicsBounds = new Rectangle(ts.position.x, ts.position.y, ts.width, ts.height);
        tiles.addChild(ts);
      } else if (tile == '*') {
        grid.set(x, y, undefined);
        sprite.center = new Point(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        this.player.bounds.center = new Point(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
      }
    });
    tiles.children.forEach((ts) => {
      const tx = ts.tx;
      const ty = ts.ty;
      ts.collision = {
        up: ty != 0 && !grid.has(tx, ty - 1),
        down: ty != grid.height - 1 && !grid.has(tx, ty + 1),
        left: tx != 0 && !grid.has(tx - 1, ty),
        right: tx != grid.width - 1 && !grid.has(tx + 1, ty),
      };
    });
    if (debug) {
      this.graphics = new Graphics();
      this.stage.addChild(this.graphics);
    }
  }
  update(delta) {
    if (input.keyPressed('Space')) {
      this.paused = !this.paused;
    }
    if (this.paused) {
      return;
    }
    this.sprite.update(delta);
    const goLeft = input.keyDown('KeyA');
    const goRight = input.keyDown('KeyD');
    const jump = input.keyPressed('KeyW');
    if (goLeft && !goRight) {
      this.sprite.play();
      this.sprite.scale.x = -1;
      this.player.velocity.x = -200;
    } else if (goRight && !goLeft) {
      this.sprite.play();
      this.sprite.scale.x = 1;
      this.player.velocity.x = 200;
    } else {
      this.sprite.stop();
      this.player.velocity.x = 0;
    }
    if (jump && this.player.grounded) {
      this.player.velocity.y = -JUMP_SPEED;
    }
    this.player.grounded = false;
    this.player.velocity.y += GRAVITY * delta / 2;
    this.player.bounds.x += this.player.velocity.x * delta;
    this.player.bounds.y += this.player.velocity.y * delta;
    this.player.velocity.y += GRAVITY * delta / 2;
    const oldY = this.player.bounds.y;
    let movedVertically = false;
    this.tiles.children.forEach((tile) => {
      const tileBounds = tile.physicsBounds;
      const collision = Rectangle.getTileCollision(this.player.bounds, tileBounds, tile.collision);
      if (!collision) {
        return;
      }
      this.player.bounds.x += collision.x;
      this.player.bounds.y += collision.y;
      if (collision.x) {
        this.player.velocity.x = 0;
      }
      if (collision.y) {
        movedVertically = true;
        this.player.velocity.y = 0;
      }
    });
    const newY = this.player.bounds.y;
    if (movedVertically && newY <= oldY) {
      this.player.grounded = true;
    }
    if (this.graphics) {
      this.graphics.clear();
      this.graphics.beginFill(0x0000FF, 0.5);
      const r = this.player.bounds;
      this.graphics.drawRect(r.x, r.y, r.width, r.height);
      this.graphics.endFill();
      this.tiles.children.forEach((tile) => {
        this.graphics.beginFill(0xFFFF00, 0.5);
        this.graphics.drawRect(tile.tx * TILE_SIZE, tile.ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        this.graphics.endFill();
      });
    }
    const bounds = this.player.bounds;
    const sprite = this.sprite;
    sprite.x = bounds.x + bounds.width * sprite.anchor.x;
    sprite.y = bounds.y + bounds.height * sprite.anchor.y;
    const spriteLeft = sprite.x - sprite.anchor.x * sprite.width;
    const spriteTop = sprite.y - sprite.anchor.y * sprite.height;
    const spriteCenterX = spriteLeft + sprite.width;
    const spriteCenterY = spriteTop + sprite.height;
    this.stage.position.set(
      (Math.floor(display.width / 2) - spriteCenterX * this.stage.scale.x),
      (Math.floor(display.height / 2) - spriteCenterY * this.stage.scale.y));
    this.stage.scale.set(2);
  }
  randomizeBackgroundColor() {
    this.backgroundColor = Math.floor(Math.random() * 0xFFFFFF);
  }
}

engine.launch(new TestScene());

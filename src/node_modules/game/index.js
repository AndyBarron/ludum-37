import 'game/style.css'; // webpack magic
import {Container, Graphics, Point, Rectangle, SCALE_MODES, settings, Sprite} from 'pixi.js';
settings.SCALE_MODE = SCALE_MODES.NEAREST;

import * as engine from 'engine';
import * as display from 'engine/display';
import * as input from 'engine/input';
import Scene from 'engine/Scene';
import TileGrid from './TileGrid';

const GRAVITY = 800;
const RAVE_INTERVAL_MS = 1000 * 1;

const LEVEL = [
  '##################################',
  '#*                               #',
  '#                                #',
  '#                                #',
  '#                                #',
  '#                                #',
  '##################################',
];

const TILE_SIZE = 32;

class TestScene extends Scene {
  init() {
    this.graphics = new Graphics();
    this.stage.addChild(this.graphics);
    this.raveHandle = window.setInterval(() => {
      // this.randomizeBackgroundColor();
    }, RAVE_INTERVAL_MS);
    this.player = {
      bounds: new Rectangle(0, 0, TILE_SIZE, TILE_SIZE),
      velocity: new Point(),
    };
    const sprite = this.sprite = Sprite.fromFrame('bunny');
    sprite.anchor.set(0.5, 1.0);
    this.stage.addChild(sprite);
    const tiles = this.tiles = new Container();
    this.stage.addChild(tiles);
    const grid = this.grid = new TileGrid(LEVEL);
    grid.forEach((tile, x, y) => {
      if (tile == '#') {
        const ts = Sprite.fromFrame('happy');
        ts.tx = x;
        ts.ty = y;
        ts.position.set(x * TILE_SIZE, y * TILE_SIZE);
        ts.width = TILE_SIZE;
        ts.height = TILE_SIZE;
        ts.physicsBounds = new Rectangle(ts.position.x, ts.position.y, ts.width, ts.height);
        tiles.addChild(ts);
      } else if (tile == '*') {
        grid.set(x, y, undefined);
        sprite.center = new Point(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        this.player.bounds.center = new Point(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
      }
    });
    tiles.children.forEach((ts) => {
      const tx = ts.tx;
      const ty = ts.ty;
      ts.collision = {
        up: ty != 0 && !grid.has(tx, ty - 1),
        down: ty != grid.height - 1 && !grid.has(tx, ty + 1),
        left: tx != 0 && !grid.has(tx - 1, ty),
        right: tx != grid.width - 1 && !grid.has(tx + 1, ty),
      };
      if (!tx && !ty) {
        window.scene = this;
      }
    });
  }
  dispose() {
    window.clearInterval(this.raveHandle);
  }
  update(delta) {
    if (input.keyPressed('Space')) {
      this.paused = !this.paused;
    }
    if (this.paused) {
      return;
    }
    const goLeft = input.keyDown('KeyA');
    const goRight = input.keyDown('KeyD');
    const jump = input.keyPressed('KeyW');
    if (goLeft && !goRight) {
      this.player.velocity.x = -300;
    } else if (goRight && !goLeft) {
      this.player.velocity.x = 300;
    } else {
      this.player.velocity.x = 0;
    }
    if (jump && this.player.grounded) {
      this.player.velocity.y = -500;
    }
    this.player.grounded = false;
    this.player.velocity.y += GRAVITY * delta / 2;
    this.player.bounds.x += this.player.velocity.x * delta;
    this.player.bounds.y += this.player.velocity.y * delta;
    this.player.velocity.y += GRAVITY * delta / 2;
    this.tiles.children.forEach((tile) => {
      const tileBounds = tile.physicsBounds;
      const collision = Rectangle.getTileCollision(this.player.bounds, tileBounds, tile.collision);
      if (!collision) {
        return;
      }
      const oldY = this.player.bounds.y;
      this.player.bounds.x += collision.x;
      this.player.bounds.y += collision.y;
      const newY = this.player.bounds.y;
      if (newY <= oldY) {
        this.player.grounded = true;
      }
      if (collision.x) {
        this.player.velocity.x = 0;
      }
      if (collision.y) {
        this.player.velocity.y = 0;
      }
    });
    this.graphics.clear();
    this.graphics.beginFill(0xFF00FF, 1.0);
    const r = this.player.bounds;
    this.graphics.drawRect(r.x, r.y, r.width, r.height);
    this.graphics.endFill();
    this.tiles.children.forEach((tile) => {
      this.graphics.beginFill(0xFFFF00, 1.0);
      this.graphics.drawRect(tile.tx * TILE_SIZE, tile.ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      this.graphics.endFill();
    });
    const bounds = this.player.bounds;
    const sprite = this.sprite;
    sprite.x = bounds.x + bounds.width * sprite.anchor.x;
    sprite.y = bounds.y + bounds.height * sprite.anchor.y;
    const spriteLeft = sprite.x - sprite.anchor.x * sprite.width;
    const spriteTop = sprite.y - sprite.anchor.y * sprite.height;
    const spriteCenterX = spriteLeft + sprite.width;
    const spriteCenterY = spriteTop + sprite.height;
    this.stage.position.set(
      (Math.floor(display.width / 2) - spriteCenterX * this.stage.scale.x),
      (Math.floor(display.height / 2) - spriteCenterY * this.stage.scale.y));
    // console.log(Math.floor(display.width / 2));
    // console.log(spriteCenterX);
    // console.log(this.stage.position);
    this.stage.scale.set(2);
  }
  randomizeBackgroundColor() {
    this.backgroundColor = Math.floor(Math.random() * 0xFFFFFF);
  }
}

engine.launch(new TestScene());
